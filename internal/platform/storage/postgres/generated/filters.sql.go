// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: filters.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countFiltersByPipeline = `-- name: CountFiltersByPipeline :one
SELECT COUNT(*) FROM filters WHERE pipeline_id = $1
`

func (q *Queries) CountFiltersByPipeline(ctx context.Context, pipelineID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countFiltersByPipeline, pipelineID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFilter = `-- name: CreateFilter :one
INSERT INTO filters (
    pipeline_id, name, description, filter_type, mode, config, code, execution_order, is_active
) VALUES ($1, $2, COALESCE($3, ''), $4, COALESCE($5, 'nocode'), COALESCE($6, '{}'::jsonb), $7, COALESCE($8, 1), COALESCE($9, TRUE))
RETURNING id, pipeline_id, name, description, filter_type, mode, config, code, is_active, execution_order, created_at, updated_at
`

func (q *Queries) CreateFilter(ctx context.Context, pipelineID uuid.UUID, name string, column3 interface{}, filterType FilterType, column5 interface{}, column6 interface{}, code pgtype.Text, column8 interface{}, column9 interface{}) (Filter, error) {
	row := q.db.QueryRow(ctx, createFilter,
		pipelineID,
		name,
		column3,
		filterType,
		column5,
		column6,
		code,
		column8,
		column9,
	)
	var i Filter
	err := row.Scan(
		&i.ID,
		&i.PipelineID,
		&i.Name,
		&i.Description,
		&i.FilterType,
		&i.Mode,
		&i.Config,
		&i.Code,
		&i.IsActive,
		&i.ExecutionOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFilter = `-- name: DeleteFilter :exec
DELETE FROM filters WHERE id = $1
`

func (q *Queries) DeleteFilter(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFilter, id)
	return err
}

const getFilterByID = `-- name: GetFilterByID :one
SELECT id, pipeline_id, name, description, filter_type, mode, config, code, is_active, execution_order, created_at, updated_at FROM filters WHERE id = $1
`

func (q *Queries) GetFilterByID(ctx context.Context, id uuid.UUID) (Filter, error) {
	row := q.db.QueryRow(ctx, getFilterByID, id)
	var i Filter
	err := row.Scan(
		&i.ID,
		&i.PipelineID,
		&i.Name,
		&i.Description,
		&i.FilterType,
		&i.Mode,
		&i.Config,
		&i.Code,
		&i.IsActive,
		&i.ExecutionOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFiltersByType = `-- name: GetFiltersByType :many
SELECT id, pipeline_id, name, description, filter_type, mode, config, code, is_active, execution_order, created_at, updated_at FROM filters 
WHERE pipeline_id = $1 AND filter_type = $2 AND is_active = TRUE
ORDER BY execution_order ASC
`

func (q *Queries) GetFiltersByType(ctx context.Context, pipelineID uuid.UUID, filterType FilterType) ([]Filter, error) {
	rows, err := q.db.Query(ctx, getFiltersByType, pipelineID, filterType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Filter{}
	for rows.Next() {
		var i Filter
		if err := rows.Scan(
			&i.ID,
			&i.PipelineID,
			&i.Name,
			&i.Description,
			&i.FilterType,
			&i.Mode,
			&i.Config,
			&i.Code,
			&i.IsActive,
			&i.ExecutionOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveFiltersByPipeline = `-- name: ListActiveFiltersByPipeline :many
SELECT id, pipeline_id, name, description, filter_type, mode, config, code, is_active, execution_order, created_at, updated_at FROM filters 
WHERE pipeline_id = $1 AND is_active = TRUE 
ORDER BY execution_order ASC
`

func (q *Queries) ListActiveFiltersByPipeline(ctx context.Context, pipelineID uuid.UUID) ([]Filter, error) {
	rows, err := q.db.Query(ctx, listActiveFiltersByPipeline, pipelineID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Filter{}
	for rows.Next() {
		var i Filter
		if err := rows.Scan(
			&i.ID,
			&i.PipelineID,
			&i.Name,
			&i.Description,
			&i.FilterType,
			&i.Mode,
			&i.Config,
			&i.Code,
			&i.IsActive,
			&i.ExecutionOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFiltersByPipeline = `-- name: ListFiltersByPipeline :many
SELECT id, pipeline_id, name, description, filter_type, mode, config, code, is_active, execution_order, created_at, updated_at FROM filters 
WHERE pipeline_id = $1 
ORDER BY execution_order ASC, created_at ASC
`

func (q *Queries) ListFiltersByPipeline(ctx context.Context, pipelineID uuid.UUID) ([]Filter, error) {
	rows, err := q.db.Query(ctx, listFiltersByPipeline, pipelineID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Filter{}
	for rows.Next() {
		var i Filter
		if err := rows.Scan(
			&i.ID,
			&i.PipelineID,
			&i.Name,
			&i.Description,
			&i.FilterType,
			&i.Mode,
			&i.Config,
			&i.Code,
			&i.IsActive,
			&i.ExecutionOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reorderFilters = `-- name: ReorderFilters :exec
UPDATE filters SET execution_order = $2, updated_at = NOW() WHERE id = $1
`

func (q *Queries) ReorderFilters(ctx context.Context, iD uuid.UUID, executionOrder int32) error {
	_, err := q.db.Exec(ctx, reorderFilters, iD, executionOrder)
	return err
}

const updateFilter = `-- name: UpdateFilter :one
UPDATE filters SET
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    filter_type = COALESCE($4, filter_type),
    mode = COALESCE($5, mode),
    config = COALESCE($6, config),
    code = COALESCE($7, code),
    execution_order = COALESCE($8, execution_order),
    is_active = COALESCE($9, is_active),
    updated_at = NOW()
WHERE id = $1
RETURNING id, pipeline_id, name, description, filter_type, mode, config, code, is_active, execution_order, created_at, updated_at
`

func (q *Queries) UpdateFilter(ctx context.Context, iD uuid.UUID, name string, description pgtype.Text, filterType FilterType, mode FilterMode, config []byte, code pgtype.Text, executionOrder int32, isActive bool) (Filter, error) {
	row := q.db.QueryRow(ctx, updateFilter,
		iD,
		name,
		description,
		filterType,
		mode,
		config,
		code,
		executionOrder,
		isActive,
	)
	var i Filter
	err := row.Scan(
		&i.ID,
		&i.PipelineID,
		&i.Name,
		&i.Description,
		&i.FilterType,
		&i.Mode,
		&i.Config,
		&i.Code,
		&i.IsActive,
		&i.ExecutionOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
