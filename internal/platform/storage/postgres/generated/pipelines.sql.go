// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: pipelines.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countPipelinesByUser = `-- name: CountPipelinesByUser :one
SELECT COUNT(*) FROM pipelines WHERE user_id = $1
`

func (q *Queries) CountPipelinesByUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPipelinesByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPipeline = `-- name: CreatePipeline :one
INSERT INTO pipelines (
    user_id, source_id, destination_id, name, description, is_active, execution_order
) VALUES ($1, $2, $3, $4, COALESCE($5, ''), COALESCE($6, TRUE), COALESCE($7, 1))
RETURNING id, user_id, source_id, destination_id, name, description, is_active, execution_order, created_at, updated_at
`

func (q *Queries) CreatePipeline(ctx context.Context, userID uuid.UUID, sourceID uuid.UUID, destinationID uuid.UUID, name string, column5 interface{}, column6 interface{}, column7 interface{}) (Pipeline, error) {
	row := q.db.QueryRow(ctx, createPipeline,
		userID,
		sourceID,
		destinationID,
		name,
		column5,
		column6,
		column7,
	)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SourceID,
		&i.DestinationID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.ExecutionOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePipeline = `-- name: DeletePipeline :exec
DELETE FROM pipelines WHERE id = $1
`

func (q *Queries) DeletePipeline(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePipeline, id)
	return err
}

const getPipelineByID = `-- name: GetPipelineByID :one
SELECT id, user_id, source_id, destination_id, name, description, is_active, execution_order, created_at, updated_at FROM pipelines WHERE id = $1
`

func (q *Queries) GetPipelineByID(ctx context.Context, id uuid.UUID) (Pipeline, error) {
	row := q.db.QueryRow(ctx, getPipelineByID, id)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SourceID,
		&i.DestinationID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.ExecutionOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPipelineWithDetails = `-- name: GetPipelineWithDetails :one
SELECT 
    p.id, p.user_id, p.source_id, p.destination_id, p.name, p.description, p.is_active, p.execution_order, p.created_at, p.updated_at,
    s.name as source_name,
    d.name as destination_name,
    d.destination_type
FROM pipelines p
JOIN sources s ON p.source_id = s.id
JOIN destinations d ON p.destination_id = d.id
WHERE p.id = $1
`

type GetPipelineWithDetailsRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	UserID          uuid.UUID          `db:"user_id" json:"user_id"`
	SourceID        uuid.UUID          `db:"source_id" json:"source_id"`
	DestinationID   uuid.UUID          `db:"destination_id" json:"destination_id"`
	Name            string             `db:"name" json:"name"`
	Description     string             `db:"description" json:"description"`
	IsActive        bool               `db:"is_active" json:"is_active"`
	ExecutionOrder  int32              `db:"execution_order" json:"execution_order"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	SourceName      string             `db:"source_name" json:"source_name"`
	DestinationName string             `db:"destination_name" json:"destination_name"`
	DestinationType DestinationType    `db:"destination_type" json:"destination_type"`
}

func (q *Queries) GetPipelineWithDetails(ctx context.Context, id uuid.UUID) (GetPipelineWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getPipelineWithDetails, id)
	var i GetPipelineWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SourceID,
		&i.DestinationID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.ExecutionOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceName,
		&i.DestinationName,
		&i.DestinationType,
	)
	return i, err
}

const listActivePipelinesBySource = `-- name: ListActivePipelinesBySource :many
SELECT id, user_id, source_id, destination_id, name, description, is_active, execution_order, created_at, updated_at FROM pipelines 
WHERE source_id = $1 AND is_active = TRUE 
ORDER BY execution_order ASC
`

func (q *Queries) ListActivePipelinesBySource(ctx context.Context, sourceID uuid.UUID) ([]Pipeline, error) {
	rows, err := q.db.Query(ctx, listActivePipelinesBySource, sourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Pipeline{}
	for rows.Next() {
		var i Pipeline
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SourceID,
			&i.DestinationID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.ExecutionOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPipelinesBySourceAndDestination = `-- name: ListPipelinesBySourceAndDestination :many
SELECT id, user_id, source_id, destination_id, name, description, is_active, execution_order, created_at, updated_at FROM pipelines 
WHERE source_id = $1 AND destination_id = $2 
ORDER BY execution_order ASC
`

func (q *Queries) ListPipelinesBySourceAndDestination(ctx context.Context, sourceID uuid.UUID, destinationID uuid.UUID) ([]Pipeline, error) {
	rows, err := q.db.Query(ctx, listPipelinesBySourceAndDestination, sourceID, destinationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Pipeline{}
	for rows.Next() {
		var i Pipeline
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SourceID,
			&i.DestinationID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.ExecutionOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPipelinesByUser = `-- name: ListPipelinesByUser :many
SELECT id, user_id, source_id, destination_id, name, description, is_active, execution_order, created_at, updated_at FROM pipelines 
WHERE user_id = $1 
ORDER BY execution_order ASC, created_at DESC
`

func (q *Queries) ListPipelinesByUser(ctx context.Context, userID uuid.UUID) ([]Pipeline, error) {
	rows, err := q.db.Query(ctx, listPipelinesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Pipeline{}
	for rows.Next() {
		var i Pipeline
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SourceID,
			&i.DestinationID,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.ExecutionOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePipeline = `-- name: UpdatePipeline :one
UPDATE pipelines SET
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    is_active = COALESCE($4, is_active),
    execution_order = COALESCE($5, execution_order),
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, source_id, destination_id, name, description, is_active, execution_order, created_at, updated_at
`

func (q *Queries) UpdatePipeline(ctx context.Context, iD uuid.UUID, name string, description string, isActive bool, executionOrder int32) (Pipeline, error) {
	row := q.db.QueryRow(ctx, updatePipeline,
		iD,
		name,
		description,
		isActive,
		executionOrder,
	)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SourceID,
		&i.DestinationID,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.ExecutionOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
