// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transformations.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countTransformationsByPipeline = `-- name: CountTransformationsByPipeline :one
SELECT COUNT(*) FROM transformations WHERE pipeline_id = $1
`

func (q *Queries) CountTransformationsByPipeline(ctx context.Context, pipelineID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countTransformationsByPipeline, pipelineID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTransformation = `-- name: CreateTransformation :one
INSERT INTO transformations (
    pipeline_id, name, description, transformation_type, mode, config, code, execution_order, is_active
) VALUES ($1, $2, COALESCE($3, ''), $4, COALESCE($5, 'nocode'), COALESCE($6, '{}'::jsonb), $7, COALESCE($8, 1), COALESCE($9, TRUE))
RETURNING id, pipeline_id, name, description, transformation_type, mode, config, code, is_active, execution_order, created_at, updated_at
`

func (q *Queries) CreateTransformation(ctx context.Context, pipelineID uuid.UUID, name string, column3 interface{}, transformationType TransformationType, column5 interface{}, column6 interface{}, code pgtype.Text, column8 interface{}, column9 interface{}) (Transformation, error) {
	row := q.db.QueryRow(ctx, createTransformation,
		pipelineID,
		name,
		column3,
		transformationType,
		column5,
		column6,
		code,
		column8,
		column9,
	)
	var i Transformation
	err := row.Scan(
		&i.ID,
		&i.PipelineID,
		&i.Name,
		&i.Description,
		&i.TransformationType,
		&i.Mode,
		&i.Config,
		&i.Code,
		&i.IsActive,
		&i.ExecutionOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTransformation = `-- name: DeleteTransformation :exec
DELETE FROM transformations WHERE id = $1
`

func (q *Queries) DeleteTransformation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTransformation, id)
	return err
}

const getBodyTransformations = `-- name: GetBodyTransformations :many
SELECT id, pipeline_id, name, description, transformation_type, mode, config, code, is_active, execution_order, created_at, updated_at FROM transformations 
WHERE pipeline_id = $1 AND transformation_type IN ('body_add', 'body_remove', 'body_modify') AND is_active = TRUE
ORDER BY execution_order ASC
`

func (q *Queries) GetBodyTransformations(ctx context.Context, pipelineID uuid.UUID) ([]Transformation, error) {
	rows, err := q.db.Query(ctx, getBodyTransformations, pipelineID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transformation{}
	for rows.Next() {
		var i Transformation
		if err := rows.Scan(
			&i.ID,
			&i.PipelineID,
			&i.Name,
			&i.Description,
			&i.TransformationType,
			&i.Mode,
			&i.Config,
			&i.Code,
			&i.IsActive,
			&i.ExecutionOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHeaderTransformations = `-- name: GetHeaderTransformations :many
SELECT id, pipeline_id, name, description, transformation_type, mode, config, code, is_active, execution_order, created_at, updated_at FROM transformations 
WHERE pipeline_id = $1 AND transformation_type IN ('header_add', 'header_remove', 'header_modify') AND is_active = TRUE
ORDER BY execution_order ASC
`

func (q *Queries) GetHeaderTransformations(ctx context.Context, pipelineID uuid.UUID) ([]Transformation, error) {
	rows, err := q.db.Query(ctx, getHeaderTransformations, pipelineID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transformation{}
	for rows.Next() {
		var i Transformation
		if err := rows.Scan(
			&i.ID,
			&i.PipelineID,
			&i.Name,
			&i.Description,
			&i.TransformationType,
			&i.Mode,
			&i.Config,
			&i.Code,
			&i.IsActive,
			&i.ExecutionOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransformationByID = `-- name: GetTransformationByID :one
SELECT id, pipeline_id, name, description, transformation_type, mode, config, code, is_active, execution_order, created_at, updated_at FROM transformations WHERE id = $1
`

func (q *Queries) GetTransformationByID(ctx context.Context, id uuid.UUID) (Transformation, error) {
	row := q.db.QueryRow(ctx, getTransformationByID, id)
	var i Transformation
	err := row.Scan(
		&i.ID,
		&i.PipelineID,
		&i.Name,
		&i.Description,
		&i.TransformationType,
		&i.Mode,
		&i.Config,
		&i.Code,
		&i.IsActive,
		&i.ExecutionOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransformationsByType = `-- name: GetTransformationsByType :many
SELECT id, pipeline_id, name, description, transformation_type, mode, config, code, is_active, execution_order, created_at, updated_at FROM transformations 
WHERE pipeline_id = $1 AND transformation_type = $2 AND is_active = TRUE
ORDER BY execution_order ASC
`

func (q *Queries) GetTransformationsByType(ctx context.Context, pipelineID uuid.UUID, transformationType TransformationType) ([]Transformation, error) {
	rows, err := q.db.Query(ctx, getTransformationsByType, pipelineID, transformationType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transformation{}
	for rows.Next() {
		var i Transformation
		if err := rows.Scan(
			&i.ID,
			&i.PipelineID,
			&i.Name,
			&i.Description,
			&i.TransformationType,
			&i.Mode,
			&i.Config,
			&i.Code,
			&i.IsActive,
			&i.ExecutionOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveTransformationsByPipeline = `-- name: ListActiveTransformationsByPipeline :many
SELECT id, pipeline_id, name, description, transformation_type, mode, config, code, is_active, execution_order, created_at, updated_at FROM transformations 
WHERE pipeline_id = $1 AND is_active = TRUE 
ORDER BY execution_order ASC
`

func (q *Queries) ListActiveTransformationsByPipeline(ctx context.Context, pipelineID uuid.UUID) ([]Transformation, error) {
	rows, err := q.db.Query(ctx, listActiveTransformationsByPipeline, pipelineID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transformation{}
	for rows.Next() {
		var i Transformation
		if err := rows.Scan(
			&i.ID,
			&i.PipelineID,
			&i.Name,
			&i.Description,
			&i.TransformationType,
			&i.Mode,
			&i.Config,
			&i.Code,
			&i.IsActive,
			&i.ExecutionOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransformationsByPipeline = `-- name: ListTransformationsByPipeline :many
SELECT id, pipeline_id, name, description, transformation_type, mode, config, code, is_active, execution_order, created_at, updated_at FROM transformations 
WHERE pipeline_id = $1 
ORDER BY execution_order ASC, created_at ASC
`

func (q *Queries) ListTransformationsByPipeline(ctx context.Context, pipelineID uuid.UUID) ([]Transformation, error) {
	rows, err := q.db.Query(ctx, listTransformationsByPipeline, pipelineID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transformation{}
	for rows.Next() {
		var i Transformation
		if err := rows.Scan(
			&i.ID,
			&i.PipelineID,
			&i.Name,
			&i.Description,
			&i.TransformationType,
			&i.Mode,
			&i.Config,
			&i.Code,
			&i.IsActive,
			&i.ExecutionOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reorderTransformations = `-- name: ReorderTransformations :exec
UPDATE transformations SET execution_order = $2, updated_at = NOW() WHERE id = $1
`

func (q *Queries) ReorderTransformations(ctx context.Context, iD uuid.UUID, executionOrder int32) error {
	_, err := q.db.Exec(ctx, reorderTransformations, iD, executionOrder)
	return err
}

const updateTransformation = `-- name: UpdateTransformation :one
UPDATE transformations SET
    name = COALESCE($2, name),
    description = COALESCE($3, description),
    transformation_type = COALESCE($4, transformation_type),
    mode = COALESCE($5, mode),
    config = COALESCE($6, config),
    code = COALESCE($7, code),
    execution_order = COALESCE($8, execution_order),
    is_active = COALESCE($9, is_active),
    updated_at = NOW()
WHERE id = $1
RETURNING id, pipeline_id, name, description, transformation_type, mode, config, code, is_active, execution_order, created_at, updated_at
`

func (q *Queries) UpdateTransformation(ctx context.Context, iD uuid.UUID, name string, description pgtype.Text, transformationType TransformationType, mode TransformationMode, config []byte, code pgtype.Text, executionOrder int32, isActive bool) (Transformation, error) {
	row := q.db.QueryRow(ctx, updateTransformation,
		iD,
		name,
		description,
		transformationType,
		mode,
		config,
		code,
		executionOrder,
		isActive,
	)
	var i Transformation
	err := row.Scan(
		&i.ID,
		&i.PipelineID,
		&i.Name,
		&i.Description,
		&i.TransformationType,
		&i.Mode,
		&i.Config,
		&i.Code,
		&i.IsActive,
		&i.ExecutionOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
