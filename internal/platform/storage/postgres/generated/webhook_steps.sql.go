// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: webhook_steps.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createWebhookStep = `-- name: CreateWebhookStep :one
INSERT INTO webhook_steps (
    webhook_event_id, pipeline_id, step_type, step_name, step_id, execution_order, 
    status, input_data, output_data, error_message, duration_ms, started_at, completed_at
) VALUES ($1, $2, $3, $4, $5, $6, COALESCE($7, 'pending'), COALESCE($8, '{}'::jsonb), 
          COALESCE($9, '{}'::jsonb), $10, $11, COALESCE($12, NOW()), $13)
RETURNING id, webhook_event_id, pipeline_id, step_type, step_name, step_id, execution_order, status, input_data, output_data, error_message, duration_ms, started_at, completed_at, created_at
`

func (q *Queries) CreateWebhookStep(ctx context.Context, webhookEventID uuid.UUID, pipelineID pgtype.UUID, stepType StepType, stepName string, stepID pgtype.UUID, executionOrder int32, column7 interface{}, column8 interface{}, column9 interface{}, errorMessage pgtype.Text, durationMs pgtype.Int4, column12 interface{}, completedAt pgtype.Timestamptz) (WebhookStep, error) {
	row := q.db.QueryRow(ctx, createWebhookStep,
		webhookEventID,
		pipelineID,
		stepType,
		stepName,
		stepID,
		executionOrder,
		column7,
		column8,
		column9,
		errorMessage,
		durationMs,
		column12,
		completedAt,
	)
	var i WebhookStep
	err := row.Scan(
		&i.ID,
		&i.WebhookEventID,
		&i.PipelineID,
		&i.StepType,
		&i.StepName,
		&i.StepID,
		&i.ExecutionOrder,
		&i.Status,
		&i.InputData,
		&i.OutputData,
		&i.ErrorMessage,
		&i.DurationMs,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteWebhookStep = `-- name: DeleteWebhookStep :exec
DELETE FROM webhook_steps WHERE id = $1
`

func (q *Queries) DeleteWebhookStep(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWebhookStep, id)
	return err
}

const getFailedWebhookSteps = `-- name: GetFailedWebhookSteps :many
SELECT 
    ws.id, ws.webhook_event_id, ws.pipeline_id, ws.step_type, ws.step_name, ws.step_id, ws.execution_order, ws.status, ws.input_data, ws.output_data, ws.error_message, ws.duration_ms, ws.started_at, ws.completed_at, ws.created_at,
    we.source_id,
    s.name as source_name,
    p.name as pipeline_name
FROM webhook_steps ws
JOIN webhook_events we ON ws.webhook_event_id = we.id
LEFT JOIN sources s ON we.source_id = s.id
LEFT JOIN pipelines p ON ws.pipeline_id = p.id
WHERE ws.status = 'failed'
ORDER BY ws.started_at DESC
LIMIT $1
`

type GetFailedWebhookStepsRow struct {
	ID             uuid.UUID          `db:"id" json:"id"`
	WebhookEventID uuid.UUID          `db:"webhook_event_id" json:"webhook_event_id"`
	PipelineID     pgtype.UUID        `db:"pipeline_id" json:"pipeline_id"`
	StepType       StepType           `db:"step_type" json:"step_type"`
	StepName       string             `db:"step_name" json:"step_name"`
	StepID         pgtype.UUID        `db:"step_id" json:"step_id"`
	ExecutionOrder int32              `db:"execution_order" json:"execution_order"`
	Status         StepStatus         `db:"status" json:"status"`
	InputData      []byte             `db:"input_data" json:"input_data"`
	OutputData     []byte             `db:"output_data" json:"output_data"`
	ErrorMessage   pgtype.Text        `db:"error_message" json:"error_message"`
	DurationMs     pgtype.Int4        `db:"duration_ms" json:"duration_ms"`
	StartedAt      pgtype.Timestamptz `db:"started_at" json:"started_at"`
	CompletedAt    pgtype.Timestamptz `db:"completed_at" json:"completed_at"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"created_at"`
	SourceID       uuid.UUID          `db:"source_id" json:"source_id"`
	SourceName     pgtype.Text        `db:"source_name" json:"source_name"`
	PipelineName   pgtype.Text        `db:"pipeline_name" json:"pipeline_name"`
}

func (q *Queries) GetFailedWebhookSteps(ctx context.Context, limit int32) ([]GetFailedWebhookStepsRow, error) {
	rows, err := q.db.Query(ctx, getFailedWebhookSteps, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFailedWebhookStepsRow{}
	for rows.Next() {
		var i GetFailedWebhookStepsRow
		if err := rows.Scan(
			&i.ID,
			&i.WebhookEventID,
			&i.PipelineID,
			&i.StepType,
			&i.StepName,
			&i.StepID,
			&i.ExecutionOrder,
			&i.Status,
			&i.InputData,
			&i.OutputData,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.SourceID,
			&i.SourceName,
			&i.PipelineName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookStepByID = `-- name: GetWebhookStepByID :one
SELECT id, webhook_event_id, pipeline_id, step_type, step_name, step_id, execution_order, status, input_data, output_data, error_message, duration_ms, started_at, completed_at, created_at FROM webhook_steps WHERE id = $1
`

func (q *Queries) GetWebhookStepByID(ctx context.Context, id uuid.UUID) (WebhookStep, error) {
	row := q.db.QueryRow(ctx, getWebhookStepByID, id)
	var i WebhookStep
	err := row.Scan(
		&i.ID,
		&i.WebhookEventID,
		&i.PipelineID,
		&i.StepType,
		&i.StepName,
		&i.StepID,
		&i.ExecutionOrder,
		&i.Status,
		&i.InputData,
		&i.OutputData,
		&i.ErrorMessage,
		&i.DurationMs,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getWebhookTraceComplete = `-- name: GetWebhookTraceComplete :many
SELECT 
    ws.id, ws.webhook_event_id, ws.pipeline_id, ws.step_type, ws.step_name, ws.step_id, ws.execution_order, ws.status, ws.input_data, ws.output_data, ws.error_message, ws.duration_ms, ws.started_at, ws.completed_at, ws.created_at,
    we.source_id,
    s.name as source_name,
    p.name as pipeline_name,
    d.name as destination_name
FROM webhook_steps ws
JOIN webhook_events we ON ws.webhook_event_id = we.id
LEFT JOIN sources s ON we.source_id = s.id
LEFT JOIN pipelines p ON ws.pipeline_id = p.id
LEFT JOIN destinations d ON p.destination_id = d.id
WHERE ws.webhook_event_id = $1
ORDER BY ws.execution_order ASC, ws.started_at ASC
`

type GetWebhookTraceCompleteRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	WebhookEventID  uuid.UUID          `db:"webhook_event_id" json:"webhook_event_id"`
	PipelineID      pgtype.UUID        `db:"pipeline_id" json:"pipeline_id"`
	StepType        StepType           `db:"step_type" json:"step_type"`
	StepName        string             `db:"step_name" json:"step_name"`
	StepID          pgtype.UUID        `db:"step_id" json:"step_id"`
	ExecutionOrder  int32              `db:"execution_order" json:"execution_order"`
	Status          StepStatus         `db:"status" json:"status"`
	InputData       []byte             `db:"input_data" json:"input_data"`
	OutputData      []byte             `db:"output_data" json:"output_data"`
	ErrorMessage    pgtype.Text        `db:"error_message" json:"error_message"`
	DurationMs      pgtype.Int4        `db:"duration_ms" json:"duration_ms"`
	StartedAt       pgtype.Timestamptz `db:"started_at" json:"started_at"`
	CompletedAt     pgtype.Timestamptz `db:"completed_at" json:"completed_at"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	SourceID        uuid.UUID          `db:"source_id" json:"source_id"`
	SourceName      pgtype.Text        `db:"source_name" json:"source_name"`
	PipelineName    pgtype.Text        `db:"pipeline_name" json:"pipeline_name"`
	DestinationName pgtype.Text        `db:"destination_name" json:"destination_name"`
}

func (q *Queries) GetWebhookTraceComplete(ctx context.Context, webhookEventID uuid.UUID) ([]GetWebhookTraceCompleteRow, error) {
	rows, err := q.db.Query(ctx, getWebhookTraceComplete, webhookEventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWebhookTraceCompleteRow{}
	for rows.Next() {
		var i GetWebhookTraceCompleteRow
		if err := rows.Scan(
			&i.ID,
			&i.WebhookEventID,
			&i.PipelineID,
			&i.StepType,
			&i.StepName,
			&i.StepID,
			&i.ExecutionOrder,
			&i.Status,
			&i.InputData,
			&i.OutputData,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.SourceID,
			&i.SourceName,
			&i.PipelineName,
			&i.DestinationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookStepsByEvent = `-- name: ListWebhookStepsByEvent :many
SELECT id, webhook_event_id, pipeline_id, step_type, step_name, step_id, execution_order, status, input_data, output_data, error_message, duration_ms, started_at, completed_at, created_at FROM webhook_steps 
WHERE webhook_event_id = $1 
ORDER BY execution_order ASC, started_at ASC
`

func (q *Queries) ListWebhookStepsByEvent(ctx context.Context, webhookEventID uuid.UUID) ([]WebhookStep, error) {
	rows, err := q.db.Query(ctx, listWebhookStepsByEvent, webhookEventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookStep{}
	for rows.Next() {
		var i WebhookStep
		if err := rows.Scan(
			&i.ID,
			&i.WebhookEventID,
			&i.PipelineID,
			&i.StepType,
			&i.StepName,
			&i.StepID,
			&i.ExecutionOrder,
			&i.Status,
			&i.InputData,
			&i.OutputData,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookStepsByEventAndType = `-- name: ListWebhookStepsByEventAndType :many
SELECT id, webhook_event_id, pipeline_id, step_type, step_name, step_id, execution_order, status, input_data, output_data, error_message, duration_ms, started_at, completed_at, created_at FROM webhook_steps 
WHERE webhook_event_id = $1 AND step_type = $2
ORDER BY execution_order ASC, started_at ASC
`

func (q *Queries) ListWebhookStepsByEventAndType(ctx context.Context, webhookEventID uuid.UUID, stepType StepType) ([]WebhookStep, error) {
	rows, err := q.db.Query(ctx, listWebhookStepsByEventAndType, webhookEventID, stepType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookStep{}
	for rows.Next() {
		var i WebhookStep
		if err := rows.Scan(
			&i.ID,
			&i.WebhookEventID,
			&i.PipelineID,
			&i.StepType,
			&i.StepName,
			&i.StepID,
			&i.ExecutionOrder,
			&i.Status,
			&i.InputData,
			&i.OutputData,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWebhookStep = `-- name: UpdateWebhookStep :one
UPDATE webhook_steps SET
    status = COALESCE($2, status),
    output_data = COALESCE($3, output_data),
    error_message = COALESCE($4, error_message),
    duration_ms = COALESCE($5, duration_ms),
    completed_at = COALESCE($6, completed_at),
    updated_at = NOW()
WHERE id = $1
RETURNING id, webhook_event_id, pipeline_id, step_type, step_name, step_id, execution_order, status, input_data, output_data, error_message, duration_ms, started_at, completed_at, created_at
`

func (q *Queries) UpdateWebhookStep(ctx context.Context, iD uuid.UUID, status StepStatus, outputData []byte, errorMessage pgtype.Text, durationMs pgtype.Int4, completedAt pgtype.Timestamptz) (WebhookStep, error) {
	row := q.db.QueryRow(ctx, updateWebhookStep,
		iD,
		status,
		outputData,
		errorMessage,
		durationMs,
		completedAt,
	)
	var i WebhookStep
	err := row.Scan(
		&i.ID,
		&i.WebhookEventID,
		&i.PipelineID,
		&i.StepType,
		&i.StepName,
		&i.StepID,
		&i.ExecutionOrder,
		&i.Status,
		&i.InputData,
		&i.OutputData,
		&i.ErrorMessage,
		&i.DurationMs,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateWebhookStepStatus = `-- name: UpdateWebhookStepStatus :one
UPDATE webhook_steps SET
    status = $2,
    error_message = COALESCE($3, error_message),
    completed_at = CASE 
        WHEN $2 IN ('success', 'failed', 'skipped') AND completed_at IS NULL 
        THEN NOW() 
        ELSE completed_at 
    END,
    duration_ms = CASE 
        WHEN $2 IN ('success', 'failed', 'skipped') AND duration_ms IS NULL
        THEN EXTRACT(EPOCH FROM (NOW() - started_at)) * 1000
        ELSE duration_ms
    END,
    updated_at = NOW()
WHERE id = $1
RETURNING id, webhook_event_id, pipeline_id, step_type, step_name, step_id, execution_order, status, input_data, output_data, error_message, duration_ms, started_at, completed_at, created_at
`

func (q *Queries) UpdateWebhookStepStatus(ctx context.Context, iD uuid.UUID, status StepStatus, errorMessage pgtype.Text) (WebhookStep, error) {
	row := q.db.QueryRow(ctx, updateWebhookStepStatus, iD, status, errorMessage)
	var i WebhookStep
	err := row.Scan(
		&i.ID,
		&i.WebhookEventID,
		&i.PipelineID,
		&i.StepType,
		&i.StepName,
		&i.StepID,
		&i.ExecutionOrder,
		&i.Status,
		&i.InputData,
		&i.OutputData,
		&i.ErrorMessage,
		&i.DurationMs,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}
